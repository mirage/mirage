(*
 * Copyright (c) 2013 Thomas Gazagnaire <thomas@gazagnaire.org>
 * Copyright (c) 2013 Anil Madhavapeddy <anil@recoil.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

open Util

type mode = [
  |`unix of [`direct | `socket ]
  |`xen
]

(* Headers *)
module Headers = struct

  let output oc =
    append oc "(* Auto-generated by mirari; if you edit by hand you may lose your changes. *)";
    newline oc

end

(* Filesystem *)
module FS = struct

  type fs = {
    name: string;
    path: string;
  }

  type t = {
    dir: string;
    fs : fs list;
  }

  let create ~dir kvs =
    let kvs = filter_map (subcommand ~prefix:"fs") kvs in
    let aux (name, path) = { name; path } in
    { dir; fs = List.map aux kvs }

  let call ?switch t =
    if not (cmd_exists "mir-crunch") then begin
      info "mir-crunch not found, so installing the mirage-fs package.";
      opam_install ?switch ["mirage-fs"];
    end;
    List.iter (fun { name; path} ->
      let path = Printf.sprintf "%s/%s" t.dir path in
      let file = Printf.sprintf "%s/filesystem_%s.ml" t.dir name in
      if Sys.file_exists path then (
        info "Creating %s." file;
        command ?switch "mir-crunch -o %s -name %S %s" file name path
      ) else
      error "The directory %s does not exist." path
    ) t.fs

  let output oc t =
    List.iter (fun { name; _ } ->
      append oc "open Filesystem_%s" name
    ) t.fs;
    newline oc

end

(* IP *)
module IP = struct

  type ipv4 = {
    address: string;
    netmask: string;
    gateway: string;
  }

  type t =
    | DHCP
    | IPv4 of ipv4

  let create kvs =
    let kvs = filter_map (subcommand ~prefix:"ip") kvs in
    let use_dhcp =
      try List.assoc "use-dhcp" kvs = "true"
      with _ -> false in
    if use_dhcp then
      DHCP
    else
      let address =
        try List.assoc "address" kvs
        with _ -> "10.0.0.2" in
      let netmask =
        try List.assoc "netmask" kvs
        with _ -> "255.255.255.0" in
      let gateway =
        try List.assoc "gateway" kvs
        with _ -> "10.0.0.1" in
      IPv4 { address; netmask; gateway }

    let output oc = function
      | DHCP   -> append oc "let ip = `DHCP"
      | IPv4 i ->
        append oc "let get = function Some x -> x | None -> failwith \"Bad IP!\"";
        append oc "let ip = `IPv4 (";
        append oc "  get (Net.Nettypes.ipv4_addr_of_string %S)," i.address;
        append oc "  get (Net.Nettypes.ipv4_addr_of_string %S)," i.netmask;
        append oc "  [get (Net.Nettypes.ipv4_addr_of_string %S)]" i.gateway;
        append oc ")";
        newline oc

end

(* HTTP listening parameters *)
module HTTP = struct

  type http = {
    port   : int;
    address: string option;
  }

  type t = http option

  let create kvs =
    let kvs = filter_map (subcommand ~prefix:"http") kvs in
    if List.mem_assoc "port" kvs &&
       List.mem_assoc "address" kvs then
      let port = List.assoc "port" kvs in
      let address = List.assoc "address" kvs in
      let port =
        try int_of_string port
        with _ -> error "%S s not a valid port number." port in
      let address = match address with
        | "*" -> None
        | a   -> Some a in
      Some { port; address }
    else
      None

  let output oc = function
    | None   -> ()
    | Some t ->
      append oc "let listen_port = %d" t.port;
      begin
        match t.address with
        | None   -> append oc "let listen_address = None"
        | Some a -> append oc "let listen_address = Net.Nettypes.ipv4_addr_of_string %S" a;
      end;
      newline oc

end

(* Main function *)
module Main = struct

  type t =
    | IP of string
    | HTTP of string
    | NOIP of string

  let create kvs =
    let kvs = filter_map (subcommand ~prefix:"main") kvs in
    let is_http = List.mem_assoc "http" kvs in
    let is_ip = List.mem_assoc "ip" kvs in
    let is_noip = List.mem_assoc "noip" kvs in
    match is_http, is_ip, is_noip with
    | false, false, false -> error "No main function is specified. You need to add 'main-{ip,http,noip}: <NAME>'."
    | true , false, false -> HTTP (List.assoc "http" kvs)
    | false, true, false  -> IP (List.assoc "ip" kvs)
    | false, false, true -> NOIP (List.assoc "noip" kvs)
    | _  -> error "Too many main functions."

  let output_http oc main =
    append oc "let main () =";
    append oc "  let spec = Cohttp_lwt_mirage.Server.({";
    append oc "    callback    = %s;" main;
    append oc "    conn_closed = (fun _ () -> ());";
    append oc "  }) in";
    append oc "  Net.Manager.create (fun mgr interface id ->";
    append oc "    Printf.eprintf \"listening to HTTP on port %%d\\\\n\" listen_port;";
    append oc "    Net.Manager.configure interface ip >>";
    append oc "    Cohttp_lwt_mirage.listen mgr (listen_address, listen_port) spec";
    append oc "  )"

  let output_ip oc main =
    append oc "let main () =";
    append oc "  Net.Manager.create (fun mgr interface id ->";
    append oc "    Net.Manager.configure interface ip >>";
    append oc "    %s mgr interface id" main;
    append oc "  )"

  let output_noip oc main = append oc "let main () = %s ()" main

  let output oc t =
    begin
      match t with
      | IP main   -> output_ip oc main
      | HTTP main -> output_http oc main
      | NOIP main -> output_noip oc main
    end;
    newline oc;
    append oc "let () = OS.Main.run (Lwt.join [main (); Backend.run ()])"

end

(* .obuild & opam file *)
module Build = struct

  type t = {
    name   : string;
    dir    : string;
    depends: string list;
    packages: string list;
  }

  let get name kvs =
    let kvs = List.filter (fun (k,_) -> k = name) kvs in
    List.fold_left (fun accu (_,v) ->
      split v ',' @ accu
    ) [] kvs

  let create ~dir ~name kvs =
    let depends = get "depends" kvs in
    let packages = get "packages" kvs in
    { name; dir; depends; packages }

  let output ~mode t =
    let file = Printf.sprintf "%s/main.obuild" t.dir in
    let deps = match t.depends with
      | [] -> ""
      | ds -> ", " ^ String.concat ", " ds in
    let oc = open_out file in
    append oc "obuild-ver: 1";
    append oc "name: %s" t.name;
    append oc "version: 0.0.0";
    newline oc;
    append oc "executable mir-%s" t.name;
    append oc "  main: main.ml";
    append oc "  buildDepends: mirage%s%s" 
     (match mode with `unix _ -> ", fd-send-recv" |_ -> "") deps;
    append oc "  pp: camlp4o";
    close_out oc

  let check t =
    if t.packages <> [] && not (cmd_exists "opam") then
      error "OPAM is not installed.";
    if not (cmd_exists "obuild") then
      error "obuild is not installed."

  let prepare ?switch ~mode t =
    check t;
    let os =
      match mode with 
      | `unix _ -> "mirage-unix"
      | `xen -> "mirage-xen" 
    in
    let net = 
      match mode with
      | `xen | `unix `direct -> "mirage-net-direct"
      | `unix `socket -> "mirage-net-socket"
    in
    let ps = "obuild" :: os :: net :: t.packages in
    opam_install ?switch ps
end

module Backend = struct

  let output ~mode dir =
    let file = Printf.sprintf "%s/backend.ml" dir in
    let oc = open_out file in
    match mode with
    |`unix _ ->
        append oc "let (>>=) = Lwt.bind

let run () =
  let backlog = 5 in
  let sockaddr = Unix.ADDR_UNIX (Printf.sprintf \"/tmp/mir-%%d.sock\" (Unix.getpid ())) in
  let sock = Lwt_unix.(socket PF_UNIX SOCK_STREAM 0) in
  let () = Lwt_unix.bind sock sockaddr in
  let () = Lwt_unix.listen sock backlog in

  let rec accept_loop () =
    Lwt_unix.accept sock
    >>= fun (fd, saddr) ->
    Printf.printf \"[backend]: Receiving connection from mirari.\\n%%!\";
    let unix_fd = Lwt_unix.unix_file_descr fd in
    let msgbuf = String.create 11 in
    let nbread, sockaddr, recvfd = Fd_send_recv.recv_fd unix_fd msgbuf 0 11 [] in
    let () = Printf.printf \"[backend]: %%d bytes read, received fd %%d\\n%%!\" nbread (Fd_send_recv.int_of_fd recvfd) in
    let id = (String.trim (String.sub msgbuf 0 10)) in
    let devtype = (if msgbuf.[10] = 'p' then OS.Netif.PCAP else OS.Netif.ETH) in
    OS.Netif.add_vif id devtype recvfd;
    Lwt_unix.(shutdown fd SHUTDOWN_ALL); (* Done, we can shutdown the connection now *)
    accept_loop ()
  in accept_loop ()"
    |`xen ->
      append oc "let run () = Lwt.return ()"

end

(* A type describing all the configuration of a mirage unikernel *)
type t = {
  file     : string;           (* Path of the mirari config file *)
  mode     : mode;             (* backend target *)
  name     : string;           (* Filename of the mirari config file*)
  dir      : string;           (* Dirname of the mirari config file *)
  main_ml  : string;           (* Name of the entry point function *)
  fs       : FS.t;             (* A value describing FS configuration *)
  ip       : IP.t;
  http     : HTTP.t;
  main     : Main.t;
  build    : Build.t;
}

let create mode file =
  let dir     = Filename.dirname file in
  let name    = Filename.chop_extension (Filename.basename file) in
  let lines   = lines_of_file file in
  let kvs     = filter_map key_value lines in
  let main_ml = Printf.sprintf "%s/main.ml" dir in
  let fs      = FS.create ~dir kvs in
  let ip      = IP.create kvs in
  let http    = HTTP.create kvs in
  let main    = Main.create kvs in
  let build   = Build.create ~name ~dir kvs in
  { file; mode; name; dir; main_ml; fs; ip; http; main; build }


let output_main t =
  let oc = open_out t.main_ml in
  Headers.output oc;
  FS.output oc t.fs;
  IP.output oc t.ip;
  HTTP.output oc t.http;
  Main.output oc t.main;
  close_out oc

let call_crunch_scripts t =
  FS.call t.fs

let call_configure_scripts ~mode t =
  in_dir t.dir (fun () ->
    command 
      "obuild configure %s" (if mode = `xen then "--executable-as-obj" else "");
  )

let call_xen_scripts t =
  let obj = Printf.sprintf "%s/dist/build/mir-%s/mir-%s.o" t.dir t.name t.name in
  let target = Printf.sprintf "%s/dist/build/mir-%s/mir-%s.xen" t.dir t.name t.name in
  if Sys.file_exists obj then begin
    let path = read_command "ocamlfind printconf path" in
    let lib = strip path ^ "/mirage-xen" in
    command "ld -d -nostdlib -m elf_x86_64 -T %s/mirage-x86_64.lds %s/x86_64.o %s %s/libocaml.a %s/libxen.a \
 %s/libxencaml.a %s/libdiet.a %s/libm.a %s/longjmp.o -o %s"  lib lib obj lib lib lib lib lib lib target;
    command "ln -nfs %s/dist/build/mir-%s/mir-%s.xen mir-%s.xen" t.dir t.name t.name t.name
  end else
    error "xen object file %s not found, cannot continue" obj

let call_build_scripts ~mode t =
  let setup = Printf.sprintf "%s/dist/setup" t.dir in
  if Sys.file_exists setup then (
    in_dir t.dir (fun () -> command "obuild build");
    (* gen_xen.sh *)
    match mode with
    |`xen -> call_xen_scripts t
    |`unix _ ->
      command "ln -nfs %s/dist/build/mir-%s/mir-%s mir-%s" t.dir t.name t.name t.name
  ) else
    error "You should run 'mirari configure %s' first." t.file

let configure ~mode ~no_install file =
  let file = scan_conf file in
  let t = create mode file in
  (* Generate main.ml *)
  info "Generating %s." t.main_ml;
  output_main t;
  (* Generate the .obuild file *)
  Build.output ~mode t.build;
  (* Generate the Backend module *)
  Backend.output ~mode t.dir;
  (* install OPAM dependencies *)
  if not no_install then Build.prepare ~mode t.build;
  (* crunch *)
  call_crunch_scripts t;
  (* obuild configure *)
  call_configure_scripts ~mode t

let build ~mode file =
    let file = scan_conf file in
    let t = create mode file in
  (* build *)
  call_build_scripts ~mode t

let run ~mode file =
  let file = scan_conf file in
  let t = create mode file in
  match mode with
  (* | None -> Unix.execv ("mir-" ^ t.name) [||] (* TODO  unix-socket backend *)  *)
  |`unix network ->
    info "+ unix mode";
    (* unix-direct backend: launch the unikernel, then create a TAP
       interface and pass the fd to the unikernel *)
      let cpid = Unix.fork () in
      if cpid = 0 then (* child code *)
        Unix.execv ("mir-" ^ t.name) [||] (* Launch the unikernel *)
      else
        begin
          match network with
          |`direct -> begin
          try
            info "Creating tap0 interface.";
            (* Force the name to be "tap0" because of MacOSX *)
            let fd, id =
              (try
                 let fd, id = Tuntap.opentap ~devname:"tap0" () in
                 (* TODO: Do not hardcode 10.0.0.1, put it in mirari config file *)
                 let () = Tuntap.set_ipv4 ~devname:"tap0" ~ipv4:"10.0.0.1" () in
                 fd, id
               with Failure m ->
                 Printf.eprintf "[mirari] Tuntap failed with error %s. Remember that %s has to be run as root have the CAP_NET_ADMIN \
 capability in order to be able to run unikernels for the UNIX backend" m Sys.argv.(0);
                 raise (Failure m)) (* Go to cleanup section *)
            in
           let sock = Unix.(socket PF_UNIX SOCK_STREAM 0) in

           let send_fd () =
             let open Unix in
                 sleep 1;
                 info "Connecting to /tmp/mir-%d.sock..." cpid;
                 connect sock (ADDR_UNIX (Printf.sprintf "/tmp/mir-%d.sock" cpid));
                 let nb_sent = Fd_send_recv.send_fd sock "tap0      e" 0 11 [] fd in
                 if nb_sent <> 11 then
                   (error "Sending fd to unikernel failed.")
                 else info "Transmitted fd ok."
             in
             send_fd ();
             let _,_ = Unix.waitpid [] cpid in ()
          with exn ->
            info "Ctrl-C received, killing child and exiting.\n%!";
            Unix.kill cpid 15; (* Send SIGTERM to the unikernel, and then exit ourselves. *)
            raise exn
          end
          |`socket -> info "Using socket networking"

      end
  |`xen -> (* xen backend *)
      info "+ xen mode"

(* For now, only delete main.{ml,obuild}, the generated symlink and do
   an obuild clean *)
let clean () =
  command "obuild clean";
  command "rm -f main.ml main.obuild mir-* backend.ml filesystem_*.ml"
