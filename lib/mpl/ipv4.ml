(* This file was autogenerated by MPL *)
open Mpl_stdlib
exception Bad_packet of string

type protocol_t = [
  |`ICMP
  |`IGMP
  |`TCP
  |`UDP
  |`Unknown of int
]

let protocol_marshal (a:protocol_t) =
  match a with
  |`ICMP -> 1
  |`IGMP -> 2
  |`TCP -> 6
  |`UDP -> 17
  |`Unknown x -> x

let protocol_unmarshal a : protocol_t =
  match a with
  |1 -> `ICMP
  |2 -> `IGMP
  |6 -> `TCP
  |17 -> `UDP
  |x -> `Unknown x

let protocol_to_string (a:protocol_t) =
  match a with
  |`ICMP -> "ICMP"
  |`IGMP -> "IGMP"
  |`TCP -> "TCP"
  |`UDP -> "UDP"
  |`Unknown x -> Printf.sprintf "%d" x

let protocol_of_string s : protocol_t option = match s with
  |"ICMP" -> Some `ICMP
  |"IGMP" -> Some `IGMP
  |"TCP" -> Some `TCP
  |"UDP" -> Some `UDP
  |_ -> None

type tos_reliability_t = [
  |`Normal
  |`Low
  |`Unknown of int
]

let tos_reliability_marshal (a:tos_reliability_t) =
  match a with
  |`Normal -> 0
  |`Low -> 1
  |`Unknown x -> x

let tos_reliability_unmarshal a : tos_reliability_t =
  match a with
  |0 -> `Normal
  |1 -> `Low
  |x -> `Unknown x

let tos_reliability_to_string (a:tos_reliability_t) =
  match a with
  |`Normal -> "Normal"
  |`Low -> "Low"
  |`Unknown x -> Printf.sprintf "%d" x

let tos_reliability_of_string s : tos_reliability_t option = match s with
  |"Normal" -> Some `Normal
  |"Low" -> Some `Low
  |_ -> None

type tos_throughput_t = [
  |`Normal
  |`Low
  |`Unknown of int
]

let tos_throughput_marshal (a:tos_throughput_t) =
  match a with
  |`Normal -> 0
  |`Low -> 1
  |`Unknown x -> x

let tos_throughput_unmarshal a : tos_throughput_t =
  match a with
  |0 -> `Normal
  |1 -> `Low
  |x -> `Unknown x

let tos_throughput_to_string (a:tos_throughput_t) =
  match a with
  |`Normal -> "Normal"
  |`Low -> "Low"
  |`Unknown x -> Printf.sprintf "%d" x

let tos_throughput_of_string s : tos_throughput_t option = match s with
  |"Normal" -> Some `Normal
  |"Low" -> Some `Low
  |_ -> None

type tos_delay_t = [
  |`Normal
  |`Low
  |`Unknown of int
]

let tos_delay_marshal (a:tos_delay_t) =
  match a with
  |`Normal -> 0
  |`Low -> 1
  |`Unknown x -> x

let tos_delay_unmarshal a : tos_delay_t =
  match a with
  |0 -> `Normal
  |1 -> `Low
  |x -> `Unknown x

let tos_delay_to_string (a:tos_delay_t) =
  match a with
  |`Normal -> "Normal"
  |`Low -> "Low"
  |`Unknown x -> Printf.sprintf "%d" x

let tos_delay_of_string s : tos_delay_t option = match s with
  |"Normal" -> Some `Normal
  |"Low" -> Some `Low
  |_ -> None

type tos_precedence_t = [
  |`Routine
  |`Priority
  |`Immediate
  |`Flash
  |`Flash_override
  |`ECP
  |`Internetwork_control
  |`Network_control
  |`Unknown of int
]

let tos_precedence_marshal (a:tos_precedence_t) =
  match a with
  |`Routine -> 0
  |`Priority -> 1
  |`Immediate -> 2
  |`Flash -> 3
  |`Flash_override -> 4
  |`ECP -> 5
  |`Internetwork_control -> 6
  |`Network_control -> 7
  |`Unknown x -> x

let tos_precedence_unmarshal a : tos_precedence_t =
  match a with
  |0 -> `Routine
  |1 -> `Priority
  |2 -> `Immediate
  |3 -> `Flash
  |4 -> `Flash_override
  |5 -> `ECP
  |6 -> `Internetwork_control
  |7 -> `Network_control
  |x -> `Unknown x

let tos_precedence_to_string (a:tos_precedence_t) =
  match a with
  |`Routine -> "Routine"
  |`Priority -> "Priority"
  |`Immediate -> "Immediate"
  |`Flash -> "Flash"
  |`Flash_override -> "Flash_override"
  |`ECP -> "ECP"
  |`Internetwork_control -> "Internetwork_control"
  |`Network_control -> "Network_control"
  |`Unknown x -> Printf.sprintf "%d" x

let tos_precedence_of_string s : tos_precedence_t option = match s with
  |"Routine" -> Some `Routine
  |"Priority" -> Some `Priority
  |"Immediate" -> Some `Immediate
  |"Flash" -> Some `Flash
  |"Flash_override" -> Some `Flash_override
  |"ECP" -> Some `ECP
  |"Internetwork_control" -> Some `Internetwork_control
  |"Network_control" -> Some `Network_control
  |_ -> None

class o
  ~(options_length:int)
  ~(data_length:int)
  (env:env) =
  object(self)
    method env = env_at env 0 self#sizeof
    method sizeof = data_length+options_length+4+4+2+1+1+1+1+2+2+1+1




    method tos_precedence =
      let __bitdummy0 = Mpl_byte.to_int (Mpl_byte.at env (0)) in
      let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
      let tos_precedence = ((__bitdummy1 lsr 5) lsl 0) in
      tos_precedence_unmarshal tos_precedence
    (* set_tos_precedence unsupported for now (type bit) *)

    method tos_delay =
      let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
      let tos_delay = (((__bitdummy1 lsr 4) land 1) lsl 0) in
      tos_delay_unmarshal tos_delay
    (* set_tos_delay unsupported for now (type bit) *)

    method tos_throughput =
      let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
      let tos_throughput = (((__bitdummy1 lsr 3) land 1) lsl 0) in
      tos_throughput_unmarshal tos_throughput
    (* set_tos_throughput unsupported for now (type bit) *)

    method tos_reliability =
      let __bitdummy1 = Mpl_byte.to_int (Mpl_byte.at env (1)) in
      let tos_reliability = (((__bitdummy1 lsr 2) land 1) lsl 0) in
      tos_reliability_unmarshal tos_reliability
    (* set_tos_reliability unsupported for now (type bit) *)



    method id =
      Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2))
    method set_id v : unit =
      Mpl_uint16.marshal (env_at env (1+1+2) 2) (Mpl_uint16.of_int v)



    method dont_fragment =
      let __bitdummy2 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2)) in
      (((__bitdummy2 lsr 6) land 1) lsl 0)
    (* set_dont_fragment unsupported for now (type bit) *)

    method can_fragment =
      let __bitdummy2 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2)) in
      (((__bitdummy2 lsr 5) land 1) lsl 0)
    (* set_can_fragment unsupported for now (type bit) *)


    method frag_offset =
      let __bitdummy2 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2)) in
      let __bitdummy3 = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2+1)) in
      (__bitdummy3 lsl 0) + (((__bitdummy2 lsr 0) land 31) lsl 8)
    (* set_frag_offset unsupported for now (type bit) *)

    method ttl =
      Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2+1+1))
    method set_ttl v : unit =
      Mpl_byte.marshal (env_at env (1+1+2+2+1+1) 1) (Mpl_byte.of_int v)

    method protocol =
      let protocol = Mpl_byte.to_int (Mpl_byte.at env (1+1+2+2+1+1+1)) in
      protocol_unmarshal protocol
    method set_protocol v : unit =
      Mpl_byte.marshal (env_at env (1+1+2+2+1+1+1) 1) (Mpl_byte.of_int v)

    method checksum =
      Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2+2+1+1+1+1))
    method set_checksum v : unit =
      Mpl_uint16.marshal (env_at env (1+1+2+2+1+1+1+1) 2) (Mpl_uint16.of_int v)

    method src =
      Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+1+1+1+1+2))
    method set_src v : unit =
      Mpl_uint32.marshal (env_at env (1+1+2+2+1+1+1+1+2) 4) (Mpl_uint32.of_int32 v)

    method dest =
      Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+1+1+1+1+2+4))
    method set_dest v : unit =
      Mpl_uint32.marshal (env_at env (1+1+2+2+1+1+1+1+2+4) 4) (Mpl_uint32.of_int32 v)

    method options =
      Mpl_raw.at env (1+1+2+2+1+1+1+1+2+4+4) options_length
    (* set_options unsupported for now (type byte array) *)
    method options_env : env = env_at env (1+1+2+2+1+1+1+1+2+4+4) options_length
    method options_frag = Mpl_raw.frag env (1+1+2+2+1+1+1+1+2+4+4) options_length
    method options_length = options_length

    method header_end = 1+1+2+2+1+1+1+1+2+4+4+options_length

    method data =
      Mpl_raw.at env (1+1+2+2+1+1+1+1+2+4+4+options_length) data_length
    (* set_data unsupported for now (type byte array) *)
    method data_env : env = env_at env (1+1+2+2+1+1+1+1+2+4+4+options_length) data_length
    method data_frag = Mpl_raw.frag env (1+1+2+2+1+1+1+1+2+4+4+options_length) data_length
    method data_length = data_length


    method prettyprint =
      let out = prerr_endline in
      out "[ Ipv4.ipv4 ]";
      (* __bitdummy0 : bound *)
      (* version : bound *)
      (* ihl : bound *)
      (* __bitdummy1 : bound *)
      out ("  tos_precedence = " ^ (tos_precedence_to_string self#tos_precedence));
      out ("  tos_delay = " ^ (tos_delay_to_string self#tos_delay));
      out ("  tos_throughput = " ^ (tos_throughput_to_string self#tos_throughput));
      out ("  tos_reliability = " ^ (tos_reliability_to_string self#tos_reliability));
      (* tos_reserved : bound *)
      (* length : bound *)
      out ("  id = " ^ (Printf.sprintf "%u" self#id));
      (* __bitdummy2 : bound *)
      (* reserved : bound *)
      out ("  dont_fragment = " ^ (Printf.sprintf "%u" self#dont_fragment));
      out ("  can_fragment = " ^ (Printf.sprintf "%u" self#can_fragment));
      (* __bitdummy3 : bound *)
      out ("  frag_offset = " ^ (Printf.sprintf "%u" self#frag_offset));
      out ("  ttl = " ^ (Printf.sprintf "%u" self#ttl));
      out ("  protocol = " ^ (protocol_to_string self#protocol));
      out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
      out ("  src = " ^ (Printf.sprintf "%lu" self#src));
      out ("  dest = " ^ (Printf.sprintf "%lu" self#dest));
      out ("  options = " ^ (Mpl_raw.prettyprint self#options));
      (* header_end : bound *)
      out ("  data = " ^ (Mpl_raw.prettyprint self#data));
      ()
  end

let t
  ?(tos_precedence=`Routine)
  ?(tos_delay=`Normal)
  ?(tos_throughput=`Normal)
  ?(tos_reliability=`Normal)
  ?(dont_fragment=0)
  ?(can_fragment=0)
  ?(frag_offset=0)
  ?(checksum=0)
  ~id
  ~ttl
  ~protocol
  ~src
  ~dest
  ~(options:('a data))
  ~(data:('a data))
  env =
    let dest___offset = 1+1+2+2+1+1+1+1+2+4+4 in
    let ___env = env_at env (1+1+2+2+1+1+1+1+2+4+4) 0 in
    let options___len = match options with 
    |`Str x -> Mpl_raw.marshal ___env x; String.length x
    |`Sub fn -> ignore(fn ___env); curpos ___env
    |`None -> 0
    |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
    let ___al = (4 - (options___len mod 4)) mod 4 in for i = 1 to ___al do
      Mpl_byte.marshal ___env (Mpl_byte.of_char '\000');
    done; let options___len = options___len + ___al in
    let options___offset = 1+1+2+2+1+1+1+1+2+4+4+options___len in
    let ___env = env_at env (1+1+2+2+1+1+1+1+2+4+4+options___len) 0 in
    let data___len = match data with 
    |`Str x -> Mpl_raw.marshal ___env x; String.length x
    |`Sub fn -> ignore(fn ___env); curpos ___env
    |`None -> 0
    |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
    let data___offset = 1+1+2+2+1+1+1+1+2+4+4+options___len+data___len in
    let version = 4 in (* const bit *)
    let ihl = (options___offset / 4) in (* bit bound *)
    let tos_precedence = tos_precedence_marshal tos_precedence in
    let tos_delay = tos_delay_marshal tos_delay in
    let tos_throughput = tos_throughput_marshal tos_throughput in
    let tos_reliability = tos_reliability_marshal tos_reliability in
    let tos_reserved = 0 in (* const bit *)
    let reserved = 0 in (* const bit *)
    if dont_fragment < 0 || dont_fragment > 1 then raise (Bad_packet "out of range (0 < dont_fragment < 1)");
    if can_fragment < 0 || can_fragment > 1 then raise (Bad_packet "out of range (0 < can_fragment < 1)");
    if frag_offset < 0 || frag_offset > 8191 then raise (Bad_packet "out of range (0 < frag_offset < 8191)");
    let __bitdummy2 = Mpl_byte.of_int ((frag_offset lsr 8) + (can_fragment lsl 5) + (dont_fragment lsl 6) + (reserved lsl 7)) in
    let __bitdummy3 = Mpl_byte.of_int ((frag_offset land 255)) in
    let __bitdummy0 = Mpl_byte.of_int (ihl + (version lsl 4)) in
    let __bitdummy1 = Mpl_byte.of_int (tos_reserved + (tos_reliability lsl 2) + (tos_throughput lsl 3) + (tos_delay lsl 4) + (tos_precedence lsl 5)) in
    let length = (Mpl_uint16.of_int data___offset) in (* bound *)
    let id = (Mpl_uint16.of_int id) in
    let ttl = (Mpl_byte.of_int ttl) in
    let __protocol = protocol_marshal protocol in
    let __protocol = (Mpl_byte.of_int __protocol) in
    let checksum = (Mpl_uint16.of_int checksum) in
    let src = (Mpl_uint32.of_int32 src) in
    let dest = (Mpl_uint32.of_int32 dest) in
    let options = options in
    let data = data in
    Mpl_byte.marshal env __bitdummy0;
    (* bit version *)
    (* bit ihl *)
    Mpl_byte.marshal env __bitdummy1;
    (* bit tos_precedence *)
    (* bit tos_delay *)
    (* bit tos_throughput *)
    (* bit tos_reliability *)
    (* bit tos_reserved *)
    Mpl_uint16.marshal env length;
    Mpl_uint16.marshal env id;
    Mpl_byte.marshal env __bitdummy2;
    (* bit reserved *)
    (* bit dont_fragment *)
    (* bit can_fragment *)
    Mpl_byte.marshal env __bitdummy3;
    (* bit frag_offset *)
    Mpl_byte.marshal env ttl;
    Mpl_byte.marshal env __protocol;
    Mpl_uint16.marshal env checksum;
    Mpl_uint32.marshal env src;
    Mpl_uint32.marshal env dest;
    skip env options___len;
    skip env data___len;
    new o
    ~options_length:options___len
    ~data_length:data___len
    env

let m (x:(env->o)) env = x env
let sizeof (x:o) = x#sizeof
let prettyprint (x:o) = x#prettyprint
let env (x:o) = x#env

let unmarshal 
  (env:env) : o =
  let __bitdummy0 = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
  let ihl = (((__bitdummy0 lsr 0) land 15) lsl 0) in (* bitu *)
  skip env 1; (* skipped __bitdummy1 *)
  let length = Mpl_uint16.unmarshal env in
  skip env 2; (* skipped id *)
  skip env 1; (* skipped __bitdummy2 *)
  skip env 1; (* skipped __bitdummy3 *)
  skip env 1; (* skipped ttl *)
  skip env 1; (* skipped protocol *)
  skip env 2; (* skipped checksum *)
  skip env 4; (* skipped src *)
  skip env 4; (* skipped dest *)
  let dest___offset = curpos env in
  let options_length = ((ihl * 4) - dest___offset) in
  skip env options_length; (* skipped options *)
  let options___offset = curpos env in
  skip env 0; (* skipped header_end *)
  let data_length = ((Mpl_uint16.to_int length) - (ihl * 4)) in
  skip env data_length; (* skipped data *)
  let data___offset = curpos env in
  new o env
  ~options_length:options_length
  ~data_length:data_length
