(* This file was autogenerated by MPL *)
open Mpl_stdlib
exception Bad_packet of string

module TimestampRequest = struct
  class o
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = 4+4+4+2+2+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)

      method identifier =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2))
      method set_identifier v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2) 2) (Mpl_uint16.of_int v)

      method sequence =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2+2))
      method set_sequence v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2+2) 2) (Mpl_uint16.of_int v)

      method origin_timestamp =
        Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+2))
      method set_origin_timestamp v : unit =
        Mpl_uint32.marshal (env_at env (1+1+2+2+2) 4) (Mpl_uint32.of_int32 v)

      method receive_timestamp =
        Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+2+4))
      method set_receive_timestamp v : unit =
        Mpl_uint32.marshal (env_at env (1+1+2+2+2+4) 4) (Mpl_uint32.of_int32 v)

      method transmit_timestamp =
        Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2+2+2+4+4))
      method set_transmit_timestamp v : unit =
        Mpl_uint32.marshal (env_at env (1+1+2+2+2+4+4) 4) (Mpl_uint32.of_int32 v)


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.TimestampRequest.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        out ("  identifier = " ^ (Printf.sprintf "%u" self#identifier));
        out ("  sequence = " ^ (Printf.sprintf "%u" self#sequence));
        out ("  origin_timestamp = " ^ (Printf.sprintf "%lu" self#origin_timestamp));
        out ("  receive_timestamp = " ^ (Printf.sprintf "%lu" self#receive_timestamp));
        out ("  transmit_timestamp = " ^ (Printf.sprintf "%lu" self#transmit_timestamp));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~identifier
    ~sequence
    ~origin_timestamp
    ~receive_timestamp
    ~transmit_timestamp
    env =
      let ptype = (Mpl_byte.of_int 13) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let identifier = (Mpl_uint16.of_int identifier) in
      let sequence = (Mpl_uint16.of_int sequence) in
      let origin_timestamp = (Mpl_uint32.of_int32 origin_timestamp) in
      let receive_timestamp = (Mpl_uint32.of_int32 receive_timestamp) in
      let transmit_timestamp = (Mpl_uint32.of_int32 transmit_timestamp) in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint16.marshal env identifier;
      Mpl_uint16.marshal env sequence;
      Mpl_uint32.marshal env origin_timestamp;
      Mpl_uint32.marshal env receive_timestamp;
      Mpl_uint32.marshal env transmit_timestamp;
      new o
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module TimeExceeded = struct
  class o
    ~(ip_header_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = ip_header_length+4+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)


      method ip_header =
        Mpl_raw.at env (1+1+2+4) ip_header_length
      (* set_ip_header unsupported for now (type byte array) *)
      method ip_header_env : env = env_at env (1+1+2+4) ip_header_length
      method ip_header_frag = Mpl_raw.frag env (1+1+2+4) ip_header_length
      method ip_header_length = ip_header_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.TimeExceeded.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        (* reserved : bound *)
        out ("  ip_header = " ^ (Mpl_raw.prettyprint self#ip_header));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~(ip_header:data)
    env =
      let ___env = env_at env (1+1+2+4) 0 in
      let ip_header___len = match ip_header with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ptype = (Mpl_byte.of_int 11) in (* const *)
      let reserved = (Mpl_uint32.of_int32 0l) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let ip_header = ip_header in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint32.marshal env reserved;
      skip env ip_header___len;
      new o
      ~ip_header_length:ip_header___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module RouterSolicitation = struct
  class o
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = 2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.RouterSolicitation.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    env =
      let ptype = (Mpl_byte.of_int 10) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      new o
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module RouterAdvertisement = struct
  class o
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = 2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.RouterAdvertisement.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    env =
      let ptype = (Mpl_byte.of_int 9) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      new o
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module EchoRequest = struct
  class o
    ~(data_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = data_length+2+2+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)

      method identifier =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2))
      method set_identifier v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2) 2) (Mpl_uint16.of_int v)

      method sequence =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2+2))
      method set_sequence v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2+2) 2) (Mpl_uint16.of_int v)

      method data =
        Mpl_raw.at env (1+1+2+2+2) data_length
      (* set_data unsupported for now (type byte array) *)
      method data_env : env = env_at env (1+1+2+2+2) data_length
      method data_frag = Mpl_raw.frag env (1+1+2+2+2) data_length
      method data_length = data_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.EchoRequest.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        out ("  identifier = " ^ (Printf.sprintf "%u" self#identifier));
        out ("  sequence = " ^ (Printf.sprintf "%u" self#sequence));
        out ("  data = " ^ (Mpl_raw.prettyprint self#data));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~identifier
    ~sequence
    ~(data:data)
    env =
      let ___env = env_at env (1+1+2+2+2) 0 in
      let data___len = match data with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ptype = (Mpl_byte.of_int 8) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let identifier = (Mpl_uint16.of_int identifier) in
      let sequence = (Mpl_uint16.of_int sequence) in
      let data = data in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint16.marshal env identifier;
      Mpl_uint16.marshal env sequence;
      skip env data___len;
      new o
      ~data_length:data___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module Redirect = struct
  class o
    ~(ip_header_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = ip_header_length+4+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)

      method gateway_ip =
        Mpl_uint32.to_int32 (Mpl_uint32.at env (1+1+2))
      method set_gateway_ip v : unit =
        Mpl_uint32.marshal (env_at env (1+1+2) 4) (Mpl_uint32.of_int32 v)

      method ip_header =
        Mpl_raw.at env (1+1+2+4) ip_header_length
      (* set_ip_header unsupported for now (type byte array) *)
      method ip_header_env : env = env_at env (1+1+2+4) ip_header_length
      method ip_header_frag = Mpl_raw.frag env (1+1+2+4) ip_header_length
      method ip_header_length = ip_header_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.Redirect.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        out ("  gateway_ip = " ^ (Printf.sprintf "%lu" self#gateway_ip));
        out ("  ip_header = " ^ (Mpl_raw.prettyprint self#ip_header));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~gateway_ip
    ~(ip_header:data)
    env =
      let ___env = env_at env (1+1+2+4) 0 in
      let ip_header___len = match ip_header with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ptype = (Mpl_byte.of_int 5) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let gateway_ip = (Mpl_uint32.of_int32 gateway_ip) in
      let ip_header = ip_header in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint32.marshal env gateway_ip;
      skip env ip_header___len;
      new o
      ~ip_header_length:ip_header___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module SourceQuench = struct
  class o
    ~(ip_header_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = ip_header_length+4+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)


      method ip_header =
        Mpl_raw.at env (1+1+2+4) ip_header_length
      (* set_ip_header unsupported for now (type byte array) *)
      method ip_header_env : env = env_at env (1+1+2+4) ip_header_length
      method ip_header_frag = Mpl_raw.frag env (1+1+2+4) ip_header_length
      method ip_header_length = ip_header_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.SourceQuench.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        (* reserved : bound *)
        out ("  ip_header = " ^ (Mpl_raw.prettyprint self#ip_header));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~(ip_header:data)
    env =
      let ___env = env_at env (1+1+2+4) 0 in
      let ip_header___len = match ip_header with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ptype = (Mpl_byte.of_int 4) in (* const *)
      let reserved = (Mpl_uint32.of_int32 0l) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let ip_header = ip_header in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint32.marshal env reserved;
      skip env ip_header___len;
      new o
      ~ip_header_length:ip_header___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module DestinationUnreachable = struct
  class o
    ~(ip_header_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = ip_header_length+4+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)


      method ip_header =
        Mpl_raw.at env (1+1+2+4) ip_header_length
      (* set_ip_header unsupported for now (type byte array) *)
      method ip_header_env : env = env_at env (1+1+2+4) ip_header_length
      method ip_header_frag = Mpl_raw.frag env (1+1+2+4) ip_header_length
      method ip_header_length = ip_header_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.DestinationUnreachable.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        (* reserved : bound *)
        out ("  ip_header = " ^ (Mpl_raw.prettyprint self#ip_header));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~(ip_header:data)
    env =
      let ___env = env_at env (1+1+2+4) 0 in
      let ip_header___len = match ip_header with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ptype = (Mpl_byte.of_int 3) in (* const *)
      let reserved = (Mpl_uint32.of_int32 0l) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let ip_header = ip_header in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint32.marshal env reserved;
      skip env ip_header___len;
      new o
      ~ip_header_length:ip_header___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

module EchoReply = struct
  class o
    ~(data_length:int)
    (env:env) =
    object(self)
      method env = env_at env 0 self#sizeof
      method sizeof = data_length+2+2+2+1+1

      method code =
        Mpl_byte.to_int (Mpl_byte.at env (1))
      method set_code v : unit =
        Mpl_byte.marshal (env_at env (1) 1) (Mpl_byte.of_int v)

      method checksum =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1))
      method set_checksum v : unit =
        Mpl_uint16.marshal (env_at env (1+1) 2) (Mpl_uint16.of_int v)

      method identifier =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2))
      method set_identifier v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2) 2) (Mpl_uint16.of_int v)

      method sequence =
        Mpl_uint16.to_int (Mpl_uint16.at env (1+1+2+2))
      method set_sequence v : unit =
        Mpl_uint16.marshal (env_at env (1+1+2+2) 2) (Mpl_uint16.of_int v)

      method data =
        Mpl_raw.at env (1+1+2+2+2) data_length
      (* set_data unsupported for now (type byte array) *)
      method data_env : env = env_at env (1+1+2+2+2) data_length
      method data_frag = Mpl_raw.frag env (1+1+2+2+2) data_length
      method data_length = data_length


      method prettyprint =
        let out = prerr_endline in
        out "[ Icmp.EchoReply.icmp ]";
        (* ptype : bound *)
        out ("  code = " ^ (Printf.sprintf "%u" self#code));
        out ("  checksum = " ^ (Printf.sprintf "%u" self#checksum));
        out ("  identifier = " ^ (Printf.sprintf "%u" self#identifier));
        out ("  sequence = " ^ (Printf.sprintf "%u" self#sequence));
        out ("  data = " ^ (Mpl_raw.prettyprint self#data));
        ()
    end

  let t
    ?(code=0)
    ?(checksum=0)
    ~identifier
    ~sequence
    ~(data:data)
    env =
      let ___env = env_at env (1+1+2+2+2) 0 in
      let data___len = match data with 
      |`Str x -> Mpl_raw.marshal ___env x; String.length x
      |`Sub fn -> fn ___env; curpos ___env
      |`None -> 0
      |`Frag t -> Mpl_raw.blit ___env t; curpos ___env in
      let ptype = (Mpl_byte.of_int 0) in (* const *)
      let code = (Mpl_byte.of_int code) in
      let checksum = (Mpl_uint16.of_int checksum) in
      let identifier = (Mpl_uint16.of_int identifier) in
      let sequence = (Mpl_uint16.of_int sequence) in
      let data = data in
      Mpl_byte.marshal env ptype;
      Mpl_byte.marshal env code;
      Mpl_uint16.marshal env checksum;
      Mpl_uint16.marshal env identifier;
      Mpl_uint16.marshal env sequence;
      skip env data___len;
      new o
      ~data_length:data___len
      env

  let m (x:(env->o)) env = x env
  let sizeof (x:o) = x#sizeof
  let prettyprint (x:o) = x#prettyprint
  let env (x:o) = x#env
end

type o = [
|`EchoReply of EchoReply.o
|`DestinationUnreachable of DestinationUnreachable.o
|`SourceQuench of SourceQuench.o
|`Redirect of Redirect.o
|`EchoRequest of EchoRequest.o
|`RouterAdvertisement of RouterAdvertisement.o
|`RouterSolicitation of RouterSolicitation.o
|`TimeExceeded of TimeExceeded.o
|`TimestampRequest of TimestampRequest.o
]

type x = [
|`EchoReply of (env -> EchoReply.o)
|`DestinationUnreachable of (env -> DestinationUnreachable.o)
|`SourceQuench of (env -> SourceQuench.o)
|`Redirect of (env -> Redirect.o)
|`EchoRequest of (env -> EchoRequest.o)
|`RouterAdvertisement of (env -> RouterAdvertisement.o)
|`RouterSolicitation of (env -> RouterSolicitation.o)
|`TimeExceeded of (env -> TimeExceeded.o)
|`TimestampRequest of (env -> TimestampRequest.o)
]

let m (x:x) env : o = match x with
|`EchoReply (fn:(env->EchoReply.o)) -> `EchoReply (fn env)
|`DestinationUnreachable (fn:(env->DestinationUnreachable.o)) -> `DestinationUnreachable (fn env)
|`SourceQuench (fn:(env->SourceQuench.o)) -> `SourceQuench (fn env)
|`Redirect (fn:(env->Redirect.o)) -> `Redirect (fn env)
|`EchoRequest (fn:(env->EchoRequest.o)) -> `EchoRequest (fn env)
|`RouterAdvertisement (fn:(env->RouterAdvertisement.o)) -> `RouterAdvertisement (fn env)
|`RouterSolicitation (fn:(env->RouterSolicitation.o)) -> `RouterSolicitation (fn env)
|`TimeExceeded (fn:(env->TimeExceeded.o)) -> `TimeExceeded (fn env)
|`TimestampRequest (fn:(env->TimestampRequest.o)) -> `TimestampRequest (fn env)

let prettyprint (x:o) = match x with
|`EchoReply x -> x#prettyprint
|`DestinationUnreachable x -> x#prettyprint
|`SourceQuench x -> x#prettyprint
|`Redirect x -> x#prettyprint
|`EchoRequest x -> x#prettyprint
|`RouterAdvertisement x -> x#prettyprint
|`RouterSolicitation x -> x#prettyprint
|`TimeExceeded x -> x#prettyprint
|`TimestampRequest x -> x#prettyprint

let sizeof (x:o) = match x with
|`EchoReply x -> x#sizeof
|`DestinationUnreachable x -> x#sizeof
|`SourceQuench x -> x#sizeof
|`Redirect x -> x#sizeof
|`EchoRequest x -> x#sizeof
|`RouterAdvertisement x -> x#sizeof
|`RouterSolicitation x -> x#sizeof
|`TimeExceeded x -> x#sizeof
|`TimestampRequest x -> x#sizeof

let env (x:o) = match x with
|`EchoReply x -> x#env
|`DestinationUnreachable x -> x#env
|`SourceQuench x -> x#env
|`Redirect x -> x#env
|`EchoRequest x -> x#env
|`RouterAdvertisement x -> x#env
|`RouterSolicitation x -> x#env
|`TimeExceeded x -> x#env
|`TimestampRequest x -> x#env


let unmarshal 
  (env:env) : o =
  let ptype = Mpl_byte.to_int (Mpl_byte.unmarshal env) in
  skip env 1; (* skipped code *)
  skip env 2; (* skipped checksum *)
  match ptype with
  |13 -> `TimestampRequest (
    skip env 2; (* skipped identifier *)
    skip env 2; (* skipped sequence *)
    skip env 4; (* skipped origin_timestamp *)
    skip env 4; (* skipped receive_timestamp *)
    skip env 4; (* skipped transmit_timestamp *)
    new TimestampRequest.o env
  )
  |11 -> `TimeExceeded (
    skip env 4; (* skipped reserved *)
    let ip_header_length = (remaining env) in
    skip env ip_header_length; (* skipped ip_header *)
    new TimeExceeded.o env
    ~ip_header_length:ip_header_length
  )
  |10 -> `RouterSolicitation (
    new RouterSolicitation.o env
  )
  |9 -> `RouterAdvertisement (
    new RouterAdvertisement.o env
  )
  |8 -> `EchoRequest (
    skip env 2; (* skipped identifier *)
    skip env 2; (* skipped sequence *)
    let data_length = (remaining env) in
    skip env data_length; (* skipped data *)
    new EchoRequest.o env
    ~data_length:data_length
  )
  |5 -> `Redirect (
    skip env 4; (* skipped gateway_ip *)
    let ip_header_length = (remaining env) in
    skip env ip_header_length; (* skipped ip_header *)
    new Redirect.o env
    ~ip_header_length:ip_header_length
  )
  |4 -> `SourceQuench (
    skip env 4; (* skipped reserved *)
    let ip_header_length = (remaining env) in
    skip env ip_header_length; (* skipped ip_header *)
    new SourceQuench.o env
    ~ip_header_length:ip_header_length
  )
  |3 -> `DestinationUnreachable (
    skip env 4; (* skipped reserved *)
    let ip_header_length = (remaining env) in
    skip env ip_header_length; (* skipped ip_header *)
    new DestinationUnreachable.o env
    ~ip_header_length:ip_header_length
  )
  |0 -> `EchoReply (
    skip env 2; (* skipped identifier *)
    skip env 2; (* skipped sequence *)
    let data_length = (remaining env) in
    skip env data_length; (* skipped data *)
    new EchoReply.o env
    ~data_length:data_length
  )
  |x -> raise (Bad_packet (Printf.sprintf ": %d" x))
